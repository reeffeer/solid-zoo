## Описание

Программа моделирует упрощённую подсистему зоопарка. В системе есть:
- **Животные** (`Animal` и конкретные реализации `Lion`, `Parrot`, `Snake`), которые имеют имя, вид и типичное поведение (звук и ежедневная активность).
- **Сотрудники** (`Employee`, `ZooKeeper`, `Vet`), которые выполняют разные виды ухода за животными: кормление, уборка вольера, медицинский осмотр и лечение.
- **Модуль учёта ухода за животными** (интерфейсы из пакета `care`: `Feedable`, `Cleanable`, `Treatable`), определяющий, кто и как может ухаживать за животными.
- **Отчётный модуль** (`ZooReportService`), который строит короткую сводку по животным и формирует расписание кормления.

Точка входа в программу — класс `App`, который создаёт несколько животных и сотрудников, демонстрирует их взаимодействие и выводит отчёты в консоль.

## Реализация принципов SOLID

### Single Responsibility Principle (SRP)

- **Класс `Animal`**: отвечает только за общие данные и базовое поведение животного (имя, вид, звук, ежедневная активность). Он не занимается вопросами кормления, лечения, хранения вольеров и отчётности.
- **Конкретные животные (`Lion`, `Parrot`, `Snake`)**: инкапсулируют только особенности конкретного вида (как звучит и как ведёт себя), не смешивая это с логикой сотрудников или отчётов.
- **`Employee`**: хранит только общие данные о сотруднике (имя, роль), но не реализует конкретные действия ухода.
- **Интерфейсы ухода (`Feedable`, `Cleanable`, `Treatable`)**: отвечают только за один аспект ухода.
- **`ZooReportService`**: занимается только формированием отчётов и не знает, кем и как именно обслуживаются животные.

Такое разделение уменьшает связность и упрощает модификацию каждой части отдельно.

### Open/Closed Principle (OCP)

- Система **открыта для расширения** новыми видами животных: чтобы добавить, например, `Giraffe`, достаточно создать новый класс, наследующий `Animal`, и переопределить методы `makeSound` и `performDailyActivity`. Существующий код (в т.ч. отчётный модуль и цикл по животным в `App`) изменять не нужно.
- Аналогично, можно добавить новый тип сотрудника, реализующий нужный набор интерфейсов ухода (например, `BirdSpecialist`, который реализует только кормление птиц), не изменяя уже существующие классы.
- Отчётный модуль `ZooReportService` работает с абстракцией `List<Animal>`. При добавлении новых животных отчёты продолжают работать без модификаций, либо могут быть локально доработаны при необходимости новых метрик.

### Liskov Substitution Principle (LSP)

- Все конкретные животные (`Lion`, `Parrot`, `Snake`) наследуются от абстрактного `Animal` и могут **свободно подставляться** везде, где ожидается `Animal`:
  - В коллекции (`List<Animal> animals` в `App`);
  - В методах ухода сотрудников, принимающих `Animal`;
  - В отчётном модуле `ZooReportService`.
- Ни один подкласс не ослабляет договор базового класса: каждый животный класс реализует `makeSound` и `performDailyActivity` в соответствии с контрактом, не бросает неожиданных исключений и не меняет ожидаемую семантику.

### Interface Segregation Principle (ISP)

- Вместо одного «толстого» интерфейса ухода за животными, были введены **узкие специализированные интерфейсы**:
  - **`Feedable`** — только кормление (`feed(Animal animal)`).
  - **`Cleanable`** — только уборка вольера (`cleanEnclosure(Animal animal)`).
  - **`Treatable`** — только лечение и медицинский осмотр (`treat(Animal animal)`).
- Сотрудники реализуют только те интерфейсы, которые им действительно нужны:
  - `ZooKeeper` реализует `Feedable` и `Cleanable` (кормление и уборка).
  - `Vet` реализует только `Treatable` (лечение).
- Базовый интерфейс `CareCapable` выступает маркером для всех, кто в принципе умеет ухаживать за животными, но не заставляет реализовывать ненужные методы.

Таким образом, ни один клиент (класс-сотрудник) не «заставлен» реализовывать методы, которые ему не нужны.

### Dependency Inversion Principle (DIP)

- Модуль отчётности `ZooReportService` зависит от **абстракции** `Animal`, а не от конкретных реализаций животных:
  - Методы `buildShortSummary` и `buildFeedingSchedule` принимают `List<Animal>`.
  - Для добавления нового вида животного нет необходимости модифицировать `ZooReportService`, достаточно, чтобы новый класс наследовал `Animal`.
- Точка входа `App` создаёт конкретные объекты и «склеивает» зависимости. При желании, создание можно вынести в отдельный конфигуратор/контейнер, и тогда высокоуровневые модули вообще не будут знать, какие конкретные реализации используются.
- Сами сотрудники (`ZooKeeper`, `Vet`) завязаны только на абстракцию `Animal`, а не на конкретные типы животных, что позволяет им работать с любыми новыми животными.

## Потенциальные проблемы при расширении функционала

- **Отсутствие слоя репозиториев/хранилища**: сейчас все данные создаются в памяти в `App`. При переходе к реальной базе данных или внешним источникам данных понадобится ввести дополнительные абстракции (репозитории, сервисы загрузки), иначе высокоуровневый код начнёт зависеть от деталей хранения.
- **Фиксированный набор операций ухода**: если понадобится добавить, например, «тренировку животных» или «участие в шоу», придётся расширять набор интерфейсов ухода и реализаций у сотрудников. Это всё ещё будет соответствовать SOLID, но число интерфейсов вырастет, и может потребоваться более сложная иерархия.
- При добавлении нового интерфейса ухода (например, `Trainable` для тренировки животных) необходимо модифицировать этот метод, добавляя новую проверку `instanceof`. **Это нарушает принцип открытости/закрытости** для отчётного модуля.

## Почему введённые абстракции улучшают дизайн

- **Разделение обязанностей** (животные, сотрудники, уход, отчёты) делает код проще для понимания и сопровождения: изменение логики отчётов не требует перекомпиляции всех животных или сотрудников.
- **Наследование от `Animal` и использование интерфейсов ухода** позволяет легко расширять систему новыми видами животных и сотрудников без переписывания существующего кода, что уменьшает риск регрессий.
- **Интерфейсы ISP (`Feedable`, `Cleanable`, `Treatable`)** предотвращают «раздувание» классов и навязывание лишних методов, что улучшает читаемость и снижает связность.
- **Зависимость от абстракций (`Animal`, интерфейсы ухода)** вместо конкретных классов делает систему гибкой: можно заменять реализации (другие виды животных, другие типы сотрудников, иные реализации отчётности) без модификации клиентского кода.


